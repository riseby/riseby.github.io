<html>
    <head>
        <meta charset="UTF-8">
        <title>PapTex</title>
        <!-- Include Our WebGL JS file -->
        <script type="text/javascript" src="webgl-utils.js"></script>
        <script src="WebGL.js" type="text/javascript"></script>
    </head>
    <body onload="WebGL()">  
      <canvas id="GLCanvas" width="512" height="512">  
            Your Browser Doesn't Support HTML5's Canvas.  
      </canvas>  
      <select onChange='shaderChanger(this.value)'>
        <option value='2'>Distvector visualization</option>
        <option value='4' selected="selecte">Anti aliasing render</option>
      </select>
      
    <script id="VertexShader" type="x-shader/x-vertex">  
        attribute vec3 VertexPosition;
        attribute vec2 TextureCoord;
        
        uniform float uXoffset;
        uniform float uYoffset;
        uniform float uScale;

        varying vec2 vTextureCoord;

        void main( void )
        {
            vec3 pos = VertexPosition + vec3(uXoffset, uYoffset, 0.0);
            pos = pos * uScale;
            gl_Position = vec4(pos, 1.0);    
            vTextureCoord = TextureCoord;
        }

    </script>

    
    <script id="FragmentShader" type="x-shader/x-fragment">  
        #ifdef GL_ES
        precision highp float;
        #endif

        varying vec2 vTextureCoord;
        uniform sampler2D texture;
        void main(void) {
            gl_FragColor = texture2D(texture, vTextureCoord.st);
        } 
    </script>  

    <script id="vertex" type="x-shader/x-vertex">  
        #ifdef GL_ES
        precision highp float;
        #endif
        // Jump flooding algorithm for EDT according
        // to Danielsson (1980) and Guodong Rong (2007),
        // with added support for anti-aliased edges.
        // Implementation by Stefan Gustavson 2010.
        // This code is in the public domain.

        // This code represents one iteration of the flood filling.
        // You need to run it multiple times with different step
        // lengths to perform a full distance transformation.
        attribute vec3 VertexPosition;
        attribute vec2 TextureCoord;
        
        //uniform float uXoffset;
        //uniform float uYoffset;
        //uniform float uScale;
        
        uniform float step;
        uniform float texw, texh;
        varying float stepu, stepv;

        varying vec2 uv;
        //varying float onestepu, onestepv;
        void main( void )
        {
            uv = TextureCoord;
            stepu = step / texw; // Saves a division in the fragment shader
            stepv = step / texh;

            vec3 pos = VertexPosition; //+ vec3(uXoffset, uYoffset, 0.0);
            //pos = pos * uScale;
            gl_Position = vec4(pos, 1.0);    
        }

    </script>

    <script id="vertex_display" type="x-shader/x-vertex">  
        #ifdef GL_ES
        precision highp float;
        #endif
        // Jump flooding algorithm for EDT according
        // to Danielsson (1980) and Guodong Rong (2007),
        // with added support for anti-aliased edges.
        // Implementation by Stefan Gustavson 2010.
        // This code is in the public domain.

        // This code represents one iteration of the flood filling.
        // You need to run it multiple times with different step
        // lengths to perform a full distance transformation.
        attribute vec3 VertexPosition;
        attribute vec2 TextureCoord;
        
        uniform float uXoffset;
        uniform float uYoffset;
        uniform float uScale;
        
        uniform float step;
        uniform float texw, texh;
        varying float stepu, stepv;

        varying vec2 uv;
        //varying float onestepu, onestepv;
        void main( void )
        {
            uv = TextureCoord;
            stepu = step / texw; // Saves a division in the fragment shader
            stepv = step / texh;

            vec3 pos = VertexPosition + vec3(uXoffset, uYoffset, 0.0);
            pos = pos * uScale;
            gl_Position = vec4(pos, 1.0);    
        }

    </script>

    <script id="fragment_seed" type="x-shader/x-fragment">  
        #ifdef GL_ES
        precision highp float;
        #endif

        // Jump flooding algorithm for EDT according
        // to Danielsson (1980) and Guodong Rong (2007),
        // with added support for anti-aliased edges.
        // Implementation by Stefan Gustavson 2010.
        // This code is in the public domain.

        // This shader initializes the distance field
        // in preparation for the flood filling.

        uniform sampler2D texture;
        uniform float texlevels;
        varying float stepu, stepv; // Unused here
        varying vec2 uv;

        // Helper function to remap unsigned normalized floats [0.0..1.0]
        // coming from a texture stored in integer format internally to a
        // signed float vector pointing exactly to a pixel centre in texture
        // space. The range of valid vectors is
        // [-1.0+0.5/texsize, 1.0-0.5/texsize], with the special value
        // -1.0-0.5*texsize (represented as integer 0) meaning
        // "distance vector still undetermined".
        // The mapping is carefully designed to map both 8 bit and 16
        // bit integer texture data to distinct and exact floating point
        // texture coordinate offsets and vice versa.
        // 8 bit integer textures can be used to transform images up to
        // size 128x128 pixels, and 16 bit integer textures can be used to
        // transform images up to 32768x32768, i.e. beyond the largest
        // texture size available in current implementations of OpenGL.
        // Direct use of integers in the shader (by means of texture2DRect
        // and GL_RG8I and GL_RG16I texture formats) could be faster, but
        // this code is conveniently compatible even with version 1.2 of GLSL
        // (i.e. OpenGL 2.1), and the main shader is limited by texture access
        // and branching, not ALU capacity, so a few extra multiplications
        // for indexing and output storage are not that bad.
        vec2 remap(vec2 floatdata) {
             return floatdata * (texlevels-1.0) / texlevels * 2.0 - 1.0;
        }

        void main( void )
        {
          float texel = texture2D(texture, uv).r;
          float myzero = 0.5 * texlevels / (texlevels - 1.0); // Represents zero
          float myinfinity = 0.0;                             // Represents infinity
          float aadist = texel;                               // Sub-pixel AA distance
          // Pixels > 0.5 are objects, others are background
          gl_FragColor = vec4(vec2(texel > 0.99999 ? myinfinity : myzero), aadist, 1.0);
        }
    </script>

    <script id="fragment_flood" type="x-shader/x-fragment">  
        #ifdef GL_ES
        precision highp float;
        #endif

        // Jump flooding algorithm for EDT according
        // to Danielsson (1980) and Guodong Rong (2007).
        // Implementation by Stefan Gustavson 2010.
        // This code is in the public domain.

        // This code represents one iteration of the flood filling.
        // You need to run it multiple times with different step
        // lengths to perform a full distance transformation.

        uniform sampler2D texture;
        uniform float texw, texh;
        uniform float texlevels;
        varying float stepu, stepv;
        varying vec2 uv;

        // Helper functions to remap unsigned normalized floats [0.0,1.0]
        // coming from an integer texture to the range we need [-1, 1].
        // The transformations are very specifically designed to map
        // integer texel values exactly to pixel centers, and vice versa.
        // (See fragment_seed.glsl for details.)
        vec2 remap(vec2 floatdata) {
             return floatdata * (texlevels - 1.0) / texlevels * 2.0 - 1.0;
        }

        vec2 remap_inv(vec2 floatvec) {
             return (floatvec + 1.0)* 0.5 * texlevels / (texlevels - 1.0);
        }

        void main( void )
        {
            // Search for better distance vectors among 8 candidates
            vec2 stepvec; // Relative offset to candidate being tested
            vec2 newvec;  // Absolute position of that candidate
            vec4 newseed; // Closest point from that candidate (.xy) and its distance (.z)
            vec4 bestseed; // Closest seed so far
            vec3 texel;
            texel = texture2D(texture, uv).rgb;
            bestseed.xy = remap(texel.rg);
            // TODO: This AA assumes texw=texh. It does not allow for non-square textures.
            bestseed.z = length(bestseed.xy) + (texel.b - 0.5)/texw; // Add AA edge offset
            bestseed.w = texel.b;                             // Save AA edge offset

            // This code depends on the texture having a CLAMP_TO_BORDER
            // attribute and a border color with R = 0.
            // The commented-out lines handle clamping to the edge explicitly
            // to avoid propagating incorrect vectors when looking outside
            // of [0,1] in u and/or v.
            // These explicit conditionals cause a slowdown of about 25%.
            // Sometimes a periodic transform with edge repeats might be
            // what you want. In that case, the texture wrap mode can be
            // set to GL_REPEAT, and the shader code can be left unchanged.

          stepvec = vec2(-stepu, -stepv);
          newvec = uv + stepvec;
          if ( all( bvec4( lessThan(newvec, vec2(1.0)), greaterThan(newvec, vec2(0.0)) ) ) ) {
            
            texel = texture2D(texture, newvec).rgb;
            newseed.xy = remap(texel.rg);
            if(newseed.x > -0.99999) { // if the new seed is not "indeterminate distance"
              newseed.xy = newseed.xy + stepvec;
              newseed.z = length(newseed.xy) + (texel.b - 0.5)/texw;
              newseed.w = texel.b;
              if(newseed.z < bestseed.z) {
                bestseed = newseed;
              }
            }
          }

          stepvec = vec2(-stepu, 0.0);
          newvec = uv + stepvec;
          if ( all( bvec4( lessThan(newvec, vec2(1.0)), greaterThan(newvec, vec2(0.0)) ) ) ) {
            texel = texture2D(texture, newvec).rgb;
            newseed.xy = remap(texel.rg);
            if(newseed.x > -0.99999) { // if the new seed is not "indeterminate distance"
              newseed.xy = newseed.xy + stepvec;
              newseed.z = length(newseed.xy) + (texel.b - 0.5)/texw;
              newseed.w = texel.b;
              if(newseed.z < bestseed.z) {
                bestseed = newseed;
              }
            }
          }

          stepvec = vec2(-stepu, stepv);
          newvec = uv + stepvec;
          if ( all( bvec4( lessThan(newvec, vec2(1.0)), greaterThan(newvec, vec2(0.0)) ) ) ) {
            texel = texture2D(texture, newvec).rgb;
            newseed.xy = remap(texel.rg);
            if(newseed.x > -0.99999) { // if the new seed is not "indeterminate distance"
              newseed.xy = newseed.xy + stepvec;
              newseed.z = length(newseed.xy) + (texel.b - 0.5)/texw;
              newseed.w = texel.b;
              if(newseed.z < bestseed.z) {
                bestseed = newseed;
              }
            }
          }

          stepvec = vec2(0.0, -stepv);
          newvec = uv + stepvec;
          if ( all( bvec4( lessThan(newvec, vec2(1.0)), greaterThan(newvec, vec2(0.0)) ) ) ) {
            texel = texture2D(texture, newvec).rgb;
            newseed.xy = remap(texel.rg);
            if(newseed.x > -0.99999) { // if the new seed is not "indeterminate distance"
              newseed.xy = newseed.xy + stepvec;
              newseed.z = length(newseed.xy) + (texel.b - 0.5)/texw;
              newseed.w = texel.b;
              if(newseed.z < bestseed.z) {
                bestseed = newseed;
              }
            }
          }
        
          stepvec = vec2(0.0, stepv);
          newvec = uv + stepvec;
          if ( all( bvec4( lessThan(newvec, vec2(1.0)), greaterThan(newvec, vec2(0.0)) ) ) ) {
            texel = texture2D(texture, newvec).rgb;
            newseed.xy = remap(texel.rg);
            if(newseed.x > -0.99999) { // if the new seed is not "indeterminate distance"
              newseed.xy = newseed.xy + stepvec;
              newseed.z = length(newseed.xy) + (texel.b - 0.5)/texw;
              newseed.w = texel.b;
              if(newseed.z < bestseed.z) {
                bestseed = newseed;
              }
            }
          }
        
          stepvec = vec2(stepu, -stepv);
          newvec = uv + stepvec;
          if ( all( bvec4( lessThan(newvec, vec2(1.0)), greaterThan(newvec, vec2(0.0)) ) ) ) {
            texel = texture2D(texture, newvec).rgb;
            newseed.xy = remap(texel.rg);
            if(newseed.x > -0.99999) { // if the new seed is not "indeterminate distance"
              newseed.xy = newseed.xy + stepvec;
              newseed.z = length(newseed.xy) + (texel.b - 0.5)/texw;
              newseed.w = texel.b;
              if(newseed.z < bestseed.z) {
                bestseed = newseed;
              }
            }
          }
        
          stepvec = vec2(stepu, 0.0);
          newvec = uv + stepvec;
          if ( all( bvec4( lessThan(newvec, vec2(1.0)), greaterThan(newvec, vec2(0.0)) ) ) ) {
            texel = texture2D(texture, newvec).rgb;
            newseed.xy = remap(texel.rg);
            if(newseed.x > -0.99999) { // if the new seed is not "indeterminate distance"
              newseed.xy = newseed.xy + stepvec;
              newseed.z = length(newseed.xy) + (texel.b - 0.5)/texw;
              newseed.w = texel.b;
              if(newseed.z < bestseed.z) {
                bestseed = newseed;
              }
            }
          }
        
          stepvec = vec2(stepu, stepv);
          newvec = uv + stepvec;
          if ( all( bvec4( lessThan(newvec, vec2(1.0)), greaterThan(newvec, vec2(0.0)) ) ) ) {
            texel = texture2D(texture, newvec).rgb;
            newseed.xy = remap(texel.rg);
            if(newseed.x > -0.99999) { // if the new seed is not "indeterminate distance"
              newseed.xy = newseed.xy + stepvec;
              newseed.z = length(newseed.xy) + (texel.b - 0.5)/texw;
              newseed.w = texel.b;
              if(newseed.z < bestseed.z) {
                bestseed = newseed;
              }
            }
          }
        
          gl_FragColor = vec4(remap_inv(bestseed.xy), bestseed.w, 1.0);
        }

</script>
<script id="fragment_display" type="x-shader/x-fragment">
    #ifdef GL_ES
    precision highp float;
    #endif
    // Jump flooding algorithm for EDT according
    // to Danielsson (1980) and Guodong Rong (2007),
    // with added support for anti-aliased edges.
    // Implementation by Stefan Gustavson 2010.
    // This code is in the public domain.

    // This shader displays the final distance field
    // visualized as an RGB image.

    uniform sampler2D texture;
    uniform float texw, texh;
    uniform float texlevels;
    varying vec2 uv;

    vec2 remap(vec2 floatdata) {
        return floatdata * (texlevels-1.0) / texlevels * 2.0 - 1.0;
    }

    void main( void )
    {
        vec3 texel;
        texel = texture2D(texture, uv).rgb;
        vec2 distvec = remap(texel.rg);
        
        //Distance vec vis.
        vec2 rainbow = 0.5+0.5*(normalize(distvec));
        gl_FragColor = vec4(rainbow, 1.0-length(distvec)*4.0, 1.0);
        
        // Distance vis.
        //float dist = length(distvec)+(texel.b-0.5)/texw;
        //gl_FragColor = vec4(vec2(mod(10.0*dist, 1.0)), texel.b, 1.0);
        //gl_FragColor = vec4(vec3(dist), 1.0);
    }
</script>
<script id="fragment1" type="x-shader/x-fragment">
    #ifdef GL_OES_standard_derivatives
    #extension GL_OES_standard_derivatives : enable
    #endif
    #ifdef GL_ES
    precision highp float;
    #endif
    // Level set contour texturing, Stefan Gustavson 2009
    // This code is in the public domain.
    uniform sampler2D texture;
    uniform float texw, texh;
    varying float stepu, stepv;
    varying vec2 uv;


    
    void main( void )
    {
      float onestepu = stepu;
      float onestepv = stepv;

      // Scale texcoords to range ([0,texw], [0,texh])
      vec2 st = uv * vec2(texw, texh);

      // Compute texel-local (u,v) coordinates for the four closest texels
      vec2 uv00 = floor(st - vec2(0.5)); // Lower left corner of lower left texel
      vec2 uvthis = floor(st); // Lower left corner of texel containing (u,v)
      vec2 uvlerp = st - uv00 - vec2(0.5); // Texel-local lerp blends [0,1]

     // Perform explicit texture interpolation of a,b,c coefficients.
     // This has several benefits: it works around the currently very bad
     // texture interpolation precision in ATI hardware, it makes it possible
     // to use local uv coordinates for each texel and thus make the texture
     // tile and easy to crop and edit, and a non-linear interpolating ramp
     // can be used for improved smoothness.

      // Center st00 on lower left texel and rescale to [0,1] for texture lookup
      vec2 st00 = (uv00  + vec2(0.5)) * vec2(onestepu, onestepv);

      // Compute g_u, g_v, D coefficients from four closest 8-bit RGBA texels
      vec4 rawtex00 = texture2D(texture, st00);
      vec4 rawtex10 = texture2D(texture, st00 + vec2(0.5*onestepu, 0.0));
      vec4 rawtex01 = texture2D(texture, st00 + vec2(0.0, 0.5*onestepv));
      vec4 rawtex11 = texture2D(texture, st00 + vec2(0.5*onestepu, 0.5*onestepv));

      // Restore the value for D from its 8-bit encoding?
      vec3 gugvD00 = vec3(-rawtex00.r, rawtex00.g, rawtex00.b);
      vec3 gugvD10 = vec3(-rawtex10.r, rawtex10.g, rawtex10.b);
      vec3 gugvD01 = vec3(-rawtex01.r, rawtex01.g, rawtex01.b);
      vec3 gugvD11 = vec3(-rawtex11.r, rawtex11.g, rawtex11.b);


      // Translate D to extrapolate F from neighboring texels to local uv
      vec2 uvoffset = uvthis - uv00; // 0 or 1 depending on (u,v) quadrant
      gugvD00.z -= dot(vec2(0.0, 0.0)-uvoffset, gugvD00.xy);
      gugvD10.z -= dot(vec2(1.0, 0.0)-uvoffset, gugvD10.xy);
      gugvD01.z -= dot(vec2(0.0, 1.0)-uvoffset, gugvD01.xy);
      gugvD11.z -= dot(vec2(1.0, 1.0)-uvoffset, gugvD11.xy);
      
      // Interpolate gugvD between four closest texels
      vec2 uvlocal = fract(st); // Texel-local st coordinates [0,1]
      // Use a cubic interpolation ramp for a smoother contour
      uvlerp = uvlerp * uvlerp * (3.0 - 2.0 * uvlerp); // 3*uv^2 - 2*uv^3
      // Interpolate along v
      vec3 gugvD0 = mix(gugvD00, gugvD01, uvlerp.y);
      vec3 gugvD1 = mix(gugvD10, gugvD11, uvlerp.y);
      // Interpolate along u
      vec3 gugvD = mix(gugvD0, gugvD1, uvlerp.x);

      // Compute  F = g_u*u + g_v*v + D
      float F = dot(gugvD, vec3(uvlocal, 1.0));
      // Compute length of local gradient transformed to fragment space
      // to perform high quality anisotopic analytic antialiasing
      float aastep = length(vec2(dot(dFdx(st), gugvD.xy), dot(dFdy(st), gugvD.xy)));
      // 'pattern' is 1 where F>0, 0 where F<0, with proper AA around F=0.
      float pattern = smoothstep(-aastep, aastep, F);

      // Final fragment color
      gl_FragColor = vec4(pattern, pattern, pattern, 1.0);
      //gl_FragColor = texture2D(texture, st);
}
</script>
<script id="fragment2" type="x-shader/x-fragment">
    #ifdef GL_OES_standard_derivatives
    #extension GL_OES_standard_derivatives : enable
    #endif
    #ifdef GL_ES
    precision highp float;
    #endif
    // Distance map contour texturing, Stefan Gustavson 2009
    // A re-implementation of Green's method, with an
    // 8-bit distance map but explicit texel interpolation.
    // This code is in the public domain.

    uniform sampler2D texture;
    uniform float texw, texh;
    uniform float texlevels;
    varying float stepu, stepv;
    varying vec2 uv;

    vec2 remap(vec2 floatdata) {
     return floatdata * (texlevels-1.0) / texlevels * 2.0 - 1.0;
    }

    void main( void )
    {
      float onestepu = stepu;
      float onestepv = stepv;

      // Scale texcoords to range ([0,texw], [0,texh])
      vec2 st = uv * vec2(texw, texh);

      // Compute texel-local (u,v) coordinates for the four closest texels
      vec2 uv00 = floor(st - vec2(0.5)); // Lower left corner of lower left texel
      vec2 uvthis = floor(st); // Lower left corner of texel containing (u,v)
      vec2 uvlerp = st - uv00 - vec2(0.5); // Texel-local lerp blends [0,1]

      // Perform explicit texture interpolation of D coefficient.
      // This works around the currently very bad texture interpolation
      // precision in ATI hardware.

      // Center st00 on lower left texel and rescale to [0,1] for texture lookup
      vec2 st00 = (uv00  + vec2(0.5)) * vec2(onestepu, onestepv);

      // Compute g_u, g_v, D coefficients from four closest 8-bit RGBA texels
      vec4 rawtex00 = texture2D(texture, st00);
      vec4 rawtex10 = texture2D(texture, st00 + vec2(0.5*onestepu, 0.0));
      vec4 rawtex01 = texture2D(texture, st00 + vec2(0.0, 0.5*onestepv));
      vec4 rawtex11 = texture2D(texture, st00 + vec2(0.5*onestepu, 0.5*onestepv));

      // Restore the value for D from its 8-bit encoding
      float D00 = length(remap(rawtex00.rg)) + (rawtex00.b-0.5)/texw;
      float D10 = length(remap(rawtex10.rg)) + (rawtex10.b-0.5)/texw;
      float D01 = length(remap(rawtex01.rg)) + (rawtex01.b-0.5)/texw;
      float D11 = length(remap(rawtex11.rg)) + (rawtex11.b-0.5)/texw;
      vec2 D00_10 =  vec2(D00, D10);
      vec2 D01_11 =  vec2(D01, D11);

      // Interpolate D between four closest texels
      vec2 uvlocal = fract(st)-0.5; // Texel-local st coordinates [-0.5,0.5]
      // Interpolate along v
      vec2 D0_1 = mix(D00_10, D01_11, uvlerp.y);
      // Interpolate along u
      float D = mix(D0_1.x, D0_1.y, uvlerp.x);

      // Perform anisotropic analytic antialiasing (fwidth() is slightly wrong)
      float aastep = length(vec2(dFdx(D), dFdy(D)));
      
      // 'pattern' is 1 where D>0, 0 where D<0, with proper AA around D=0.
      float pattern = smoothstep(-aastep, aastep, D);

      // Final fragment color
      gl_FragColor = vec4(pattern, pattern, pattern, 1.0);
    }
</script>
    </body>
</html>