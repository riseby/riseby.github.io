<html>
    <head>
        <meta charset="UTF-8">
        <title>PapTex</title>
        <!-- Include Our WebGL JS file -->
        <script type="text/javascript" src="webgl-utils.js"></script>
        <script src="WebGL.js" type="text/javascript"></script>
    </head>
    <body onload="WebGL()">  
      <canvas id="GLCanvas" width="512" height="512">  
            Your Browser Doesn't Support HTML5's Canvas.  
      </canvas>  
      
    <script id="VertexShader" type="x-shader/x-vertex">  
        attribute vec3 VertexPosition;
        attribute vec2 TextureCoord;
        
        uniform float uXoffset;
        uniform float uYoffset;
        uniform float uScale;

        varying vec2 vTextureCoord;

        void main( void )
        {
            vec3 pos = VertexPosition + vec3(uXoffset, uYoffset, 0.0);
            pos = pos * uScale;
            gl_Position = vec4(pos, 1.0);    
            vTextureCoord = TextureCoord;
        }

    </script>

    
    <script id="FragmentShader" type="x-shader/x-fragment">  
        #ifdef GL_ES
        precision highp float;
        #endif

        varying vec2 vTextureCoord;
        uniform sampler2D texture;
        void main(void) {
            gl_FragColor = texture2D(texture, vTextureCoord.st);
        } 
    </script>  

    <script id="vertex" type="x-shader/x-vertex">  
        #ifdef GL_ES
        precision highp float;
        #endif
        // Jump flooding algorithm for EDT according
        // to Danielsson (1980) and Guodong Rong (2007),
        // with added support for anti-aliased edges.
        // Implementation by Stefan Gustavson 2010.
        // This code is in the public domain.

        // This code represents one iteration of the flood filling.
        // You need to run it multiple times with different step
        // lengths to perform a full distance transformation.
        attribute vec3 VertexPosition;
        attribute vec2 TextureCoord;
        
        uniform float uXoffset;
        uniform float uYoffset;
        uniform float uScale;
        
        uniform float step;
        uniform float texw, texh;
        varying float stepu, stepv;

        varying vec2 uv;

        void main( void )
        {
            uv = TextureCoord;
            stepu = step / texw; // Saves a division in the fragment shader
            stepv = step / texh;

            vec3 pos = VertexPosition + vec3(uXoffset, uYoffset, 0.0);
            pos = pos * uScale;
            gl_Position = vec4(pos, 1.0);    
        }

    </script>

    <script id="fragment_seed" type="x-shader/x-fragment">  
        #ifdef GL_ES
        precision highp float;
        #endif

        // Jump flooding algorithm for EDT according
        // to Danielsson (1980) and Guodong Rong (2007),
        // with added support for anti-aliased edges.
        // Implementation by Stefan Gustavson 2010.
        // This code is in the public domain.

        // This shader initializes the distance field
        // in preparation for the flood filling.

        uniform sampler2D texture;
        uniform float texlevels;
        varying float stepu, stepv; // Unused here
        varying vec2 uv;

        // Helper function to remap unsigned normalized floats [0.0..1.0]
        // coming from a texture stored in integer format internally to a
        // signed float vector pointing exactly to a pixel centre in texture
        // space. The range of valid vectors is
        // [-1.0+0.5/texsize, 1.0-0.5/texsize], with the special value
        // -1.0-0.5*texsize (represented as integer 0) meaning
        // "distance vector still undetermined".
        // The mapping is carefully designed to map both 8 bit and 16
        // bit integer texture data to distinct and exact floating point
        // texture coordinate offsets and vice versa.
        // 8 bit integer textures can be used to transform images up to
        // size 128x128 pixels, and 16 bit integer textures can be used to
        // transform images up to 32768x32768, i.e. beyond the largest
        // texture size available in current implementations of OpenGL.
        // Direct use of integers in the shader (by means of texture2DRect
        // and GL_RG8I and GL_RG16I texture formats) could be faster, but
        // this code is conveniently compatible even with version 1.2 of GLSL
        // (i.e. OpenGL 2.1), and the main shader is limited by texture access
        // and branching, not ALU capacity, so a few extra multiplications
        // for indexing and output storage are not that bad.
        vec2 remap(vec2 floatdata) {
             return floatdata * (texlevels-1.0) / texlevels * 2.0 - 1.0;
        }

        void main( void )
        {
          float texel = texture2D(texture, uv).r;
          float myzero = 0.5 * texlevels / (texlevels - 1.0); // Represents zero
          float myinfinity = 0.0;                             // Represents infinity
          float aadist = texel;                               // Sub-pixel AA distance
          // Pixels > 0.5 are objects, others are background
          //gl_FragColor = vec4(vec2(texel > 0.5 ? myinfinity : myzero), aadist, 1.0);
          gl_FragColor = vec4(texel > 0.5 ? myinfinity : myzero);
        }
    </script>

    <script id="fragment_flood" type="x-shader/x-fragment">  
        #ifdef GL_ES
        precision highp float;
        #endif

        // Jump flooding algorithm for EDT according
        // to Danielsson (1980) and Guodong Rong (2007),
        // with added support for anti-aliased edges.
        // Implementation by Stefan Gustavson 2010.
        // This code is in the public domain.

        // This code represents one iteration of the flood filling.
        // You need to run it multiple times with different step
        // lengths to perform a full distance transformation.

        uniform sampler2D texture;
        uniform float texw, texh;
        uniform float texlevels;
        varying float stepu, stepv;
        varying vec2 uv;

        // Helper functions to remap unsigned normalized floats [0.0,1.0]
        // coming from an integer texture to the range we need [-1, 1].
        // The transformations are very specifically designed to map
        // integer texel values exactly to pixel centers, and vice versa.
        // (See fragment_seed.glsl for details.)
        vec2 remap(vec2 floatdata) {
             return floatdata * (texlevels - 1.0) / texlevels * 2.0 - 1.0;
        }

        vec2 remap_inv(vec2 floatvec) {
             return (floatvec + 1.0)* 0.5 * texlevels / (texlevels - 1.0);
        }

        void main( void )
        {
            // Search for better distance vectors among 8 candidates
            vec2 stepvec;   // Relative offset to candidate being tested
            vec2 newvec;    // Absolute position of that candidate
            vec4 newseed;   // Closest point from that candidate (.xy),
                            // its AA distance (.z) and its grayscale value (.w)
            vec4 bestseed;  // Closest seed so far
            vec3 texel;
            texel = texture2D(texture, uv).rgb;
            bestseed.xy = remap(texel.rg);
            // TODO: This AA assumes texw=texh. It does not allow for non-square textures.
            bestseed.z = length(bestseed.xy) + (texel.b - 0.5)/texw; // Add AA edge offset
            bestseed.w = texel.b;                             // Save AA edge offset

            // This code depends on the texture having a CLAMP_TO_BORDER
            // attribute and a border color with R = 0.
            // The commented-out lines handle clamping to the edge explicitly
            // to avoid propagating incorrect vectors when looking outside
            // of [0,1] in u and/or v.
            // These explicit conditionals cause a slowdown of about 25%.
            // Sometimes a periodic transform with edge repeats might be
            // what you want. In that case, the texture wrap mode can be
            // set to GL_REPEAT, and the shader code can be left unchanged.

            stepvec = vec2(-stepu, -stepv);
            newvec = uv + stepvec;
            texel = texture2D(texture, newvec).rgb;
            newseed.xy = remap(texel.rg);
            if(newseed.x > -0.99999) { // if the new seed is not "indeterminate distance"
                newseed.xy = newseed.xy + stepvec;
                newseed.z = length(newseed.xy) + (texel.b - 0.5)/texw;
                newseed.w = texel.b;
                if(newseed.z < bestseed.z) {
                    bestseed = newseed;
                }
            }

            stepvec = vec2(-stepu, 0.0);
            newvec = uv + stepvec;
            texel = texture2D(texture, newvec).rgb;
            newseed.xy = remap(texel.rg);
            if(newseed.x > -0.99999) { // if the new seed is not "indeterminate distance"
                newseed.xy = newseed.xy + stepvec;
                newseed.z = length(newseed.xy) + (texel.b - 0.5)/texw;
                newseed.w = texel.b;
                if(newseed.z < bestseed.z) {
                    bestseed = newseed;
                }
            }

            stepvec = vec2(-stepu, stepv);
            newvec = uv + stepvec;
            texel = texture2D(texture, newvec).rgb;
            newseed.xy = remap(texel.rg);
            if(newseed.x > -0.99999) { // if the new seed is not "indeterminate distance"
                newseed.xy = newseed.xy + stepvec;
                newseed.z = length(newseed.xy) + (texel.b - 0.5)/texw;
                newseed.w = texel.b;
                if(newseed.z < bestseed.z) {
                    bestseed = newseed;
                }
            }

            stepvec = vec2(0.0, -stepv);
            newvec = uv + stepvec;
            texel = texture2D(texture, newvec).rgb;
            newseed.xy = remap(texel.rg);
                if(newseed.x > -0.99999) { // if the new seed is not "indeterminate distance"
                newseed.xy = newseed.xy + stepvec;
                newseed.z = length(newseed.xy) + (texel.b - 0.5)/texw;
                newseed.w = texel.b;
                if(newseed.z < bestseed.z) {
                    bestseed = newseed;
                }
            }

            stepvec = vec2(0.0, stepv);
            newvec = uv + stepvec;
            texel = texture2D(texture, newvec).rgb;
            newseed.xy = remap(texel.rg);
            if(newseed.x > -0.99999) { // if the new seed is not "indeterminate distance"
                newseed.xy = newseed.xy + stepvec;
                newseed.z = length(newseed.xy) + (texel.b - 0.5)/texw;
                newseed.w = texel.b;
                if(newseed.z < bestseed.z) {
                    bestseed = newseed;
                }
            }

            stepvec = vec2(stepu, -stepv);
            newvec = uv + stepvec;
            texel = texture2D(texture, newvec).rgb;
            newseed.xy = remap(texel.rg);
            if(newseed.x > -0.99999) { // if the new seed is not "indeterminate distance"
                newseed.xy = newseed.xy + stepvec;
                newseed.z = length(newseed.xy) + (texel.b - 0.5)/texw;
                newseed.w = texel.b;
                if(newseed.z < bestseed.z) {
                    bestseed = newseed;
                }
            }

            stepvec = vec2(stepu, 0.0);
            newvec = uv + stepvec;
            texel = texture2D(texture, newvec).rgb;
            newseed.xy = remap(texel.rg);
            if(newseed.x > -0.99999) { // if the new seed is not "indeterminate distance"
                newseed.xy = newseed.xy + stepvec;
                newseed.z = length(newseed.xy) + (texel.b - 0.5)/texw;
                newseed.w = texel.b;
                if(newseed.z < bestseed.z) {
                    bestseed = newseed;
                }
            }

            stepvec = vec2(stepu, stepv);
            newvec = uv + stepvec;
            texel = texture2D(texture, newvec).rgb;
            newseed.xy = remap(texel.rg);
            if(newseed.x > -0.99999) { // if the new seed is not "indeterminate distance"
                newseed.xy = newseed.xy + stepvec;
                newseed.z = length(newseed.xy) + (texel.b - 0.5)/texw;
                newseed.w = texel.b;
                if(newseed.z < bestseed.z) {
                    bestseed = newseed;
                }
            }

            gl_FragColor = vec4(remap_inv(bestseed.xy), 0.0, 1.0);
        }
</script>
<script id="fragment_display" type="x-shader/x-fragment">
    #ifdef GL_ES
    precision highp float;
    #endif
    // Jump flooding algorithm for EDT according
    // to Danielsson (1980) and Guodong Rong (2007),
    // with added support for anti-aliased edges.
    // Implementation by Stefan Gustavson 2010.
    // This code is in the public domain.

    // This shader displays the final distance field
    // visualized as an RGB image.

    uniform sampler2D texture;
    uniform float texw, texh;
    uniform float texlevels;
    varying vec2 uv;

    vec2 remap(vec2 floatdata) {
        return floatdata * (texlevels-1.0) / texlevels * 2.0 - 1.0;
    }

    void main( void )
    {
        vec3 texel;
        texel = texture2D(texture, uv).rgb;
        vec2 distvec = remap(texel.rg);
        vec2 rainbow = 0.5+0.5*(normalize(distvec));
        gl_FragColor = vec4(rainbow, 1.0-length(distvec)*4.0, 1.0);
        //float dist = length(distvec)+(texel.b-0.5)/texw;
        //gl_FragColor = vec4(vec2(mod(10.0*dist, 1.0)), texel.b, 1.0);
    }
</script>
    </body>
</html>